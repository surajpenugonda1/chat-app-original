"use client"

import { useState, useEffect, useRef, useCallback, useMemo } from "react"
import { useRouter } from "next/navigation"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Separator } from "@/components/ui/separator"
import { useToast } from "@/components/ui/use-toast"
import { Search, Send, Trash2, ArrowLeft, Plus, LogOut, Paperclip, X, MoreVertical, PanelLeft } from "lucide-react"
import { useAuth } from "@/components/auth-provider"
import { fetchPersonas, fetchPersonaById, fetchUserAssignedPersonas } from "@/lib/api"
import type { Persona } from "@/lib/types"
import { cn } from "@/lib/utils"
import { useChat } from "@/hooks/use-chat"
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar"
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet"
import { useMobile } from "@/hooks/use-mobile"
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu"
import { MessageBubble } from "@/components/message-bubble"
import { AudioRecorder } from "@/components/audio-recorder"
import { Tooltip, TooltipContent, TooltipTrigger, TooltipProvider } from "@/components/ui/tooltip"

// FIXED: Simplified interfaces - removed selectedPersonas to prevent re-renders
interface SidebarState {
  allPersonas: Persona[]
  selectedPersonas: Set<string> // Keep for compatibility but don't use actively
  searchQuery: string
  sidebarCollapsed: boolean
}

interface ChatState {
  currentPersona: Persona | null
  isRecording: boolean
  copiedMessageId: string | null
  isLoadingMessages: boolean
  isInitialized: boolean
}

export default function ChatPage({ params }: { params: { personaId: string } }) {
  const router = useRouter()
  const { toast } = useToast()
  const { user, logout } = useAuth()
  const isMobile = useMobile()

  // Memoize personaId to prevent unnecessary effects
  const personaId = useMemo(() => params.personaId, [params.personaId])

  // Separate state management - FIXED: removed selectedPersonas to prevent re-renders
  const [sidebarState, setSidebarState] = useState<SidebarState>({
    allPersonas: [],
    selectedPersonas: new Set(), // Keep for interface compatibility but don't use
    searchQuery: "",
    sidebarCollapsed: false,
  })

  const [chatState, setChatState] = useState<ChatState>({
    currentPersona: null,
    isRecording: false,
    copiedMessageId: null,
    isLoadingMessages: false,
    isInitialized: false,
  })

  const messagesEndRef = useRef<HTMLDivElement>(null)
  const fileInputRef = useRef<HTMLInputElement>(null)
  const timeoutRef = useRef<NodeJS.Timeout>()

  // Use chat hook with stable personaId
  const { messages, input, setInput, handleSubmit, isLoading, clearMessages, addMessage } = useChat({
    personaId: personaId,
  })

  // FIXED: Memoized filtered personas - stable dependencies to prevent re-renders
  const filteredPersonas = useMemo(() => {
    const { allPersonas, searchQuery } = sidebarState
    
    // Show all user's personas (simplified logic)
    if (!searchQuery.trim()) {
      return allPersonas
    }
    
    const query = searchQuery.toLowerCase()
    return allPersonas.filter((persona) =>
      persona.name.toLowerCase().includes(query) ||
      persona.description.toLowerCase().includes(query)
    )
  }, [sidebarState.allPersonas, sidebarState.searchQuery])

  // Redirect if no user - simplified
  useEffect(() => {
    if (!user) {
      router.push("/login")
    }
  }, [user, router])

  // FIXED: Load initial data - properly handle persona access validation
  useEffect(() => {
    if (!user) return
    if (chatState.isInitialized) return

    let isMounted = true
    const controller = new AbortController()

    const loadData = async () => {
      try {
        setChatState(prev => ({ ...prev, isLoadingMessages: true }))
        
        const [userAssignedPersonas, currentPersonaData] = await Promise.all([
          fetchUserAssignedPersonas(),
          fetchPersonaById(personaId).catch(() => null), // Handle case where user doesn't have access
        ])

        if (isMounted) {
          // Check if current persona is accessible to user
          const assignedPersonaIds = new Set(userAssignedPersonas.map((p: Persona) => p.id))
          
          if (!assignedPersonaIds.has(personaId)) {
            // User doesn't have access to this persona, redirect to first available persona
            if (userAssignedPersonas.length > 0) {
              router.push(`/chat/${userAssignedPersonas[0].id}`)
              return
            } else {
              // No personas assigned, redirect to personas page
              router.push("/personas")
              return
            }
          }
          
          setSidebarState(prev => ({
            ...prev,
            allPersonas: userAssignedPersonas,
            // Remove selectedPersonas management - just show all user personas
          }))
          
          setChatState(prev => ({
            ...prev,
            currentPersona: currentPersonaData,
            isLoadingMessages: false,
            isInitialized: true
          }))
        }
      } catch (error) {
        if (isMounted && !controller.signal.aborted) {
          setChatState(prev => ({ ...prev, isLoadingMessages: false }))
          toast({
            variant: "destructive",
            title: "Error",
            description: "Failed to load data",
          })
        }
      }
    }

    loadData()

    return () => {
      isMounted = false
      controller.abort()
    }
  }, [user, personaId, toast, router])

  // FIXED: Handle persona switching - use ref to track current persona to prevent loops
  const currentPersonaRef = useRef<string | null>(null)
  
  useEffect(() => {
    if (!chatState.isInitialized || !sidebarState.allPersonas.length) return

    const persona = sidebarState.allPersonas.find(p => p.id === personaId)
    
    // Only update if persona exists and is different from current
    if (persona && currentPersonaRef.current !== persona.id) {
      currentPersonaRef.current = persona.id
      
      setChatState(prev => ({ 
        ...prev, 
        currentPersona: persona,
        isLoadingMessages: true 
      }))
      
      clearMessages()

      // Simulate loading with cleanup
      timeoutRef.current = setTimeout(() => {
        setChatState(prev => ({ ...prev, isLoadingMessages: false }))
      }, 1000)
    }

    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current)
      }
    }
  }, [personaId, sidebarState.allPersonas, chatState.isInitialized, clearMessages])

  // FIXED: Auto-scroll - use callback ref to prevent unnecessary re-renders
  const scrollToBottom = useCallback(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" })
  }, [])

  useEffect(() => {
    const timeoutId = setTimeout(scrollToBottom, 100)
    return () => clearTimeout(timeoutId)
  }, [messages.length, scrollToBottom])

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current)
      }
    }
  }, [])

  // FIXED: Stable callback functions - removed unnecessary dependencies
  const handlePersonaSelect = useCallback((personaId: string) => {
    router.push(`/chat/${personaId}`)
  }, [router])

  const handleLogout = useCallback(() => {
    logout()
    router.push("/")
    toast({
      title: "Logged out",
      description: "You have been successfully logged out.",
    })
  }, [logout, router, toast])

  const handleClearChat = useCallback(() => {
    clearMessages()
    toast({
      title: "Chat cleared",
      description: "All messages have been cleared.",
    })
  }, [clearMessages, toast])

  const handleBackToPersonas = useCallback(() => {
    router.push("/personas")
  }, [router])

  const handleAddPersona = useCallback(() => {
    router.push("/personas")
  }, [router])

  // FIXED: Handle remove persona logic - simplified without selectedPersonas
  const handleRemovePersona = useCallback((personaIdToRemove: string) => {
    // Since we're showing all user personas, "remove" means navigate away from current
    if (personaIdToRemove === personaId) {
      const remainingPersonas = sidebarState.allPersonas.filter(p => p.id !== personaIdToRemove)
      if (remainingPersonas.length > 0) {
        router.push(`/chat/${remainingPersonas[0].id}`)
      } else {
        router.push("/personas")
      }
    }
  }, [router, personaId, sidebarState.allPersonas])

  const handleCopyMessage = useCallback(async (messageId: string, content: string) => {
    try {
      await navigator.clipboard.writeText(content)
      setChatState(prev => ({ ...prev, copiedMessageId: messageId }))
      
      // Clear copied state after 2 seconds
      setTimeout(() => {
        setChatState(prev => ({ ...prev, copiedMessageId: null }))
      }, 2000)
      
      toast({
        title: "Copied!",
        description: "Message copied to clipboard.",
      })
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Failed to copy",
        description: "Could not copy message to clipboard.",
      })
    }
  }, [toast])

  const handleAudioMessage = useCallback((audioBlob: Blob) => {
    // Convert audio to text (mock implementation)
    const mockTranscription = "This is a mock transcription of the audio message."
    setInput(mockTranscription)
    toast({
      title: "Audio transcribed",
      description: "Your audio message has been converted to text.",
    })
  }, [setInput, toast])

  const handleFileUpload = useCallback((files: FileList) => {
    const file = files[0]
    if (file) {
      const fileMessage = `[File uploaded: ${file.name} (${(file.size / 1024).toFixed(1)}KB)]`
      addMessage({
        role: "user",
        content: fileMessage,
      })
      toast({
        title: "File uploaded",
        description: `${file.name} has been uploaded.`,
      })
    }
  }, [addMessage, toast])

  // Sidebar state handlers
  const handleSidebarSearchChange = useCallback((value: string) => {
    setSidebarState(prev => ({ ...prev, searchQuery: value }))
  }, [])

  const handleToggleSidebar = useCallback(() => {
    setSidebarState(prev => ({ ...prev, sidebarCollapsed: !prev.sidebarCollapsed }))
  }, [])

  const handleSetIsRecording = useCallback((recording: boolean) => {
    setChatState(prev => ({ ...prev, isRecording: recording }))
  }, [])

  // FIXED: Memoized components - extracted outside to prevent recreation
  const MessageSkeleton = useMemo(() => {
    const MessageSkeletonComponent = () => (
      <div className="flex gap-3 max-w-[85%] mr-auto mb-4">
        <div className="h-8 w-8 rounded-full bg-muted animate-pulse" />
        <div className="flex flex-col gap-1 flex-1">
          <div className="bg-muted rounded-2xl px-4 py-3">
            <div className="space-y-2">
              <div className="h-4 bg-muted-foreground/20 rounded animate-pulse" />
              <div className="h-4 bg-muted-foreground/20 rounded w-3/4 animate-pulse" />
            </div>
          </div>
          <div className="h-3 bg-muted-foreground/20 rounded w-16 animate-pulse" />
        </div>
      </div>
    )
    return MessageSkeletonComponent
  }, [])

  // FIXED: PersonasList component - handle empty state and show available personas count
  const PersonasList = useMemo(() => {
    const PersonasListComponent = () => (
      <div className="flex h-full flex-col bg-background">
        <div className="p-4 border-b">
          <div className="flex items-center justify-between mb-3">
            {!sidebarState.sidebarCollapsed && (
              <h3 className="font-semibold text-sm text-muted-foreground uppercase tracking-wide flex-1">
                Your Personas ({sidebarState.allPersonas.length})
              </h3>
            )}
            <Button
              variant="ghost"
              size="sm"
              onClick={handleAddPersona}
              className={cn(sidebarState.sidebarCollapsed && "mx-auto")}
            >
              <Plus className="h-4 w-4" />
            </Button>
          </div>
          {!sidebarState.sidebarCollapsed && (
            <div className="relative">
              <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
              <Input
                placeholder="Search your personas..."
                className="pl-10"
                value={sidebarState.searchQuery}
                onChange={(e) => handleSidebarSearchChange(e.target.value)}
              />
            </div>
          )}
        </div>
        <ScrollArea className="flex-1">
          <div className="p-2 space-y-1">
            {filteredPersonas.length === 0 ? (
              <div className="p-4 text-center text-muted-foreground text-sm">
                {sidebarState.searchQuery ? "No personas found" : "No personas available"}
              </div>
            ) : (
              filteredPersonas.map((persona) => (
                <Tooltip key={persona.id}>
                  <TooltipTrigger asChild>
                    <div
                      className={cn(
                        "group flex items-center justify-between rounded-lg p-3 hover:bg-muted/50 transition-colors cursor-pointer",
                        persona.id === personaId && "bg-muted",
                        sidebarState.sidebarCollapsed && "justify-center p-2",
                      )}
                      onClick={() => handlePersonaSelect(persona.id)}
                    >
                      <div className="flex items-center min-w-0 flex-1">
                        <Avatar className={cn("shrink-0", sidebarState.sidebarCollapsed ? "h-8 w-8" : "h-8 w-8 mr-3")}>
                          <AvatarImage src={persona.avatarUrl || "/placeholder.svg"} alt={persona.name} />
                          <AvatarFallback>{persona.name.charAt(0)}</AvatarFallback>
                        </Avatar>
                        {!sidebarState.sidebarCollapsed && (
                          <div className="flex-1 text-left min-w-0">
                            <div className="font-medium text-sm truncate">{persona.name}</div>
                            <div className="text-xs text-muted-foreground truncate">{persona.description}</div>
                          </div>
                        )}
                      </div>
                      {!sidebarState.sidebarCollapsed && sidebarState.allPersonas.length > 1 && (
                        <Button
                          variant="ghost"
                          size="sm"
                          className="opacity-0 group-hover:opacity-100 transition-opacity"
                          onClick={(e) => {
                            e.stopPropagation()
                            handleRemovePersona(persona.id)
                          }}
                        >
                          <X className="h-4 w-4" />
                        </Button>
                      )}
                    </div>
                  </TooltipTrigger>
                  <TooltipContent side="right" className={cn(!sidebarState.sidebarCollapsed && "hidden")}>
                    <div>
                      <div className="font-medium">{persona.name}</div>
                      <div className="text-xs text-muted-foreground">{persona.description}</div>
                    </div>
                  </TooltipContent>
                </Tooltip>
              ))
            )}
          </div>
        </ScrollArea>
      </div>
    )
    return PersonasListComponent
  }, [
    filteredPersonas,
    sidebarState.sidebarCollapsed,
    sidebarState.allPersonas.length,
    sidebarState.searchQuery,
    personaId,
    handleAddPersona,
    handleSidebarSearchChange,
    handlePersonaSelect,
    handleRemovePersona,
  ])

  // Early return if no user
  if (!user) return null

  return (
    <TooltipProvider>
      <div className="flex h-screen bg-background">
        {/* Desktop Sidebar */}
        {!isMobile && (
          <div
            className={cn(
              "border-r h-full transition-all duration-300",
              sidebarState.sidebarCollapsed ? "w-16" : "w-80",
            )}
          >
            <PersonasList />
          </div>
        )}

        {/* Main chat area */}
        <div className="flex flex-col flex-1 min-w-0">
          {/* Header */}
          <header className="sticky top-0 z-10 border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
            <div className="flex h-16 items-center px-4">
              {!isMobile && (
                <Button variant="ghost" size="icon" onClick={handleToggleSidebar} className="mr-2">
                  <PanelLeft className="h-5 w-5" />
                </Button>
              )}

              {isMobile && (
                <Sheet>
                  <SheetTrigger asChild>
                    <Button variant="ghost" size="icon" className="mr-2">
                      <Avatar className="h-8 w-8">
                        <AvatarImage
                          src={chatState.currentPersona?.avatarUrl || "/placeholder.svg"}
                          alt={chatState.currentPersona?.name}
                        />
                        <AvatarFallback>{chatState.currentPersona?.name?.charAt(0) || "?"}</AvatarFallback>
                      </Avatar>
                    </Button>
                  </SheetTrigger>
                  <SheetContent side="left" className="p-0 w-80">
                    <PersonasList />
                  </SheetContent>
                </Sheet>
              )}

              <Button variant="ghost" size="icon" className="mr-2" onClick={handleBackToPersonas}>
                <ArrowLeft className="h-5 w-5" />
              </Button>

              <div className="flex items-center flex-1 min-w-0">
                <Avatar className="h-10 w-10 mr-3">
                  <AvatarImage
                    src={chatState.currentPersona?.avatarUrl || "/placeholder.svg"}
                    alt={chatState.currentPersona?.name}
                  />
                  <AvatarFallback>{chatState.currentPersona?.name?.charAt(0) || "?"}</AvatarFallback>
                </Avatar>
                <div className="flex flex-col min-w-0">
                  <div className="font-semibold truncate">{chatState.currentPersona?.name}</div>
                  <div className="text-xs text-muted-foreground truncate">{chatState.currentPersona?.description}</div>
                </div>
              </div>

              <div className="flex items-center gap-2">
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button variant="ghost" size="icon">
                      <MoreVertical className="h-5 w-5" />
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="end">
                    <DropdownMenuItem onClick={handleClearChat}>
                      <Trash2 className="mr-2 h-4 w-4" />
                      Clear chat
                    </DropdownMenuItem>
                    <DropdownMenuItem onClick={handleLogout}>
                      <LogOut className="mr-2 h-4 w-4" />
                      Logout
                    </DropdownMenuItem>
                  </DropdownMenuContent>
                </DropdownMenu>
              </div>
            </div>
          </header>

          {/* Messages area */}
          <ScrollArea className="flex-1 p-4">
            <div className="space-y-4 max-w-4xl mx-auto">
              {chatState.isLoadingMessages ? (
                <>
                  <MessageSkeleton />
                  <MessageSkeleton />
                  <MessageSkeleton />
                </>
              ) : messages.length === 0 ? (
                <div className="flex flex-col items-center justify-center h-full min-h-[60vh] text-center p-8">
                  <div className="rounded-full bg-primary/10 p-6 mb-6">
                    <Avatar className="h-20 w-20">
                      <AvatarImage
                        src={chatState.currentPersona?.avatarUrl || "/placeholder.svg"}
                        alt={chatState.currentPersona?.name}
                      />
                      <AvatarFallback className="text-2xl">
                        {chatState.currentPersona?.name?.charAt(0) || "?"}
                      </AvatarFallback>
                    </Avatar>
                  </div>
                  <h3 className="text-2xl font-semibold mb-3">Chat with {chatState.currentPersona?.name}</h3>
                  <p className="text-muted-foreground mb-8 max-w-md">{chatState.currentPersona?.description}</p>
                  <div className="w-full max-w-md space-y-3">
                    {chatState.currentPersona?.sampleQuestions?.map((question, index) => (
                      <Button
                        key={index}
                        variant="outline"
                        className="w-full justify-start text-left h-auto p-4 whitespace-normal bg-transparent"
                        onClick={() => setInput(question)}
                      >
                        {question}
                      </Button>
                    ))}
                  </div>
                </div>
              ) : (
                messages.map((message) => (
                  <MessageBubble
                    key={message.id}
                    message={message}
                    onCopy={handleCopyMessage}
                    isCopied={chatState.copiedMessageId === message.id}
                  />
                ))
              )}
              <div ref={messagesEndRef} />
            </div>
          </ScrollArea>

          <Separator />

          {/* Input area */}
          <div className="p-4 bg-background">
            <div className="max-w-4xl mx-auto">
              <form onSubmit={handleSubmit} className="flex gap-2 items-end">
                <div className="flex-1 relative">
                  <Input
                    placeholder="Type your message..."
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    disabled={isLoading}
                    className="pr-20 min-h-[44px] resize-none"
                    onKeyDown={(e) => {
                      if (e.key === "Enter" && !e.shiftKey) {
                        e.preventDefault()
                        handleSubmit(e as any)
                      }
                    }}
                  />
                  <div className="absolute right-2 top-1/2 -translate-y-1/2 flex items-center gap-1">
                    <input
                      ref={fileInputRef}
                      type="file"
                      className="hidden"
                      onChange={(e) => e.target.files && handleFileUpload(e.target.files)}
                      accept="image/*,audio/*,.pdf,.doc,.docx,.txt"
                    />
                    <Button
                      type="button"
                      variant="ghost"
                      size="icon"
                      className="h-8 w-8"
                      onClick={() => fileInputRef.current?.click()}
                    >
                      <Paperclip className="h-4 w-4" />
                    </Button>
                    <AudioRecorder
                      onRecordingComplete={handleAudioMessage}
                      isRecording={chatState.isRecording}
                      setIsRecording={handleSetIsRecording}
                    />
                  </div>
                </div>
                <Button
                  type="submit"
                  size="icon"
                  disabled={isLoading || (!input.trim() && !chatState.isRecording)}
                  className="h-[44px] w-[44px] shrink-0"
                >
                  <Send className="h-4 w-4" />
                </Button>
              </form>
              <div className="flex items-center justify-center mt-2">
                <p className="text-xs text-muted-foreground">Press Enter to send, Shift+Enter for new line</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </TooltipProvider>
  )
}